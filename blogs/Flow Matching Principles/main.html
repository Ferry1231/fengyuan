<!DOCTYPE html>
<html>
<head>
<title>main.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///labdata1/fengyuanliu/academic-homepage-modernism/%5C%5CUsers%5C%5Cfengyuanliu%5C%5CDownloads%5C%5Clavender%5C%5CLavender.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="flow-matching-principles">Flow Matching Principles</h1>
<p>This article mainly introduces the background and mathematical principles of Flow Matching. As the author is from an artificial intelligence background rather than mathematics, this article focuses on learning and understanding Flow Matching from the perspective of a deep learning practitioner. Many descriptions may lack rigorous mathematical proofs and explanations, and I ask for readers' understanding.</p>
<p>(References are temporarily omitted)</p>
<p>NFs, CNFs, and Flow Matching are flow-based techniques primarily used in generative models. The main task of generative models is to derive complex unknown distributions from known simple distributions, such as obtaining the distribution of an image dataset from standard Gaussian noise. The development of flow-based techniques involves continuously improving the tools of velocity fields and flows to better accomplish the task of fitting/transforming distributions. The essence of flow-based methods is to solve for the probability distribution of target points.</p>
<h2 id="0-vector-fields-velocity-fields-and-flows">0. Vector Fields, Velocity Fields, and Flows</h2>
<p><strong>Vector Field</strong> $V(x)$ is a vector field defined in space, representing the direction and magnitude at each point $x$.</p>
<p><strong>Velocity Field</strong> $v(x, t)$ is a special type of vector field, indicating the rate of change and tangential direction at each point $x$. Similar to the concept of velocity in physics, in deep learning, the velocity field is also used to represent &quot;displacement&quot;â€”the rate of change of data points.</p>
<p>In mathematical physics, a <strong>flow</strong> refers to a continuous change process evolving over time, such as the evolution of a dynamic system. In generative modeling, a flow describes the transformation process of data points, embodying the evolution of their distribution. For example, in CNFs (Continuous Normalizing Flows, introduced later), a flow can be expressed as follows:</p>
<p>Given a velocity field $v(x, t)$, the displacement $x = x(t)$, the evolution process can be described by the following partial differential equation:</p>
<p>$$
\frac{\partial{x(t)}}{\partial t} = v(x(t), t)
$$</p>
<p>Let $X_0 = x(0)$, then the flow is $\Phi^t(X_0) = x(t)$, which describes the process of evolving from $t=0$ to the current moment, i.e., the evolution of its probability distribution.</p>
<p>In NFs (Normalizing Flows, introduced later), although the transformation of the distribution is discrete, it essentially still represents the change process of the probability distribution, so it is also called a flow.</p>
<h2 id="1-nfs-normalizing-flows">1. NFs: Normalizing Flows</h2>
<p>NFs (Normalizing Flows) are a probability modeling method based on invertible transformations. Through a series of invertible transformations, a simple distribution (e.g., standard Gaussian distribution) can be transformed into a complex target distribution while maintaining a strict probability computation process. The mathematical form is as follows:</p>
<p>Given a distribution $z_0 \sim p(z_0)$,</p>
<p>and a series of invertible transformations: ${f_1, f_2, ..., f_k}$,</p>
<p>we have $z_i = f_i(z_{i-1}), p(z_i) = p(z_{i-1})|\det \frac{\partial f_i}{\partial z_{i-1}} |^{-1}$. After $K$ transformations, the target probability distribution can be obtained as follows:</p>
<p>$$
\log p(z_k) = \log p(z_0) - \Sigma_{i=1}^K \log |\det \frac{\partial f_i}{\partial z_{i-1}} |
$$</p>
<p>This is the solution for the target distribution.</p>
<p><img src="images/5v2-519b7d06728cb1c2dfff6153ef37b9b7.jpg" alt="NFs Transformation Process"></p>
<p><strong>Main Drawbacks of Normalizing Flows</strong></p>
<ol>
<li>All transformations $f$ must be invertible. First, common neural networks (e.g., ResNet, Transformer) are not necessarily invertible, making implementation challenging. Second, the invertibility of the model limits its expressive power, i.e., it struggles to effectively fit high-dimensional data distributions.</li>
<li>The number of network transformations is finite, limiting expressive power, with fixed sampling paths and low sampling efficiency.</li>
<li>The computational cost is high, as each transformation requires calculating the Jacobian determinant.</li>
</ol>
<h2 id="2-cnfs-continuous-normalizing-flows">2. CNFs: Continuous Normalizing Flows</h2>
<p>CNFs (Continuous Normalizing Flows) extend the discrete transformations in Normalizing Flows to a continuous scenario. In traditional NFs, the overall distribution transformation is achieved through a series of discrete invertible transformations $f$. CNFs introduce a continuous transformation process, making the transformation smoother and enhancing the model's expressive power.</p>
<p>CNFs define a continuous-time dynamic system, using an Ordinary Differential Equation (ODE) to describe the overall change:</p>
<p>Assume the initial distribution is $z_0 \sim p(z_0)$, then the ODE describing the change process is as follows:</p>
<p>$$
\frac{dz(t)}{dt} = f(z(t), t)
$$</p>
<p>where $f$ is a given vector field (i.e., velocity field), describing the rate and direction of change of $z$ at each moment.</p>
<p>Similar to NFs, the Jacobian determinant is needed to compute the probability change process. According to the Liouville theorem, the change in probability density $p(z(t))$ can be described by the following equation:</p>
<p>$$
\frac{\partial p(z(t))}{\partial t} = - \nabla (p(z(t))f(z(t), t))
$$</p>
<p>The rate of change is related to the divergence of the vector field. This equation can be solved using numerical methods for ODEs and PDEs (e.g., Euler method, Runge-Kutta method, etc.).</p>
<p><img src="images/6v2-47d1a64181b4cad4420dd375fb9b495e.jpg" alt="From the original paper: https://arxiv.org/abs/1806.07366"></p>
<h2 id="3-flow-matching">3. Flow Matching</h2>
<p>FM (Flow Matching) is a method based on CNFs, used to train invertible generative models. In CNFs, directly solving the trajectory change $x(t)$ or the change in probability density $p(z(t))$ is quite challenging.</p>
<p>Given an initial state $X_0$ and its velocity field, the probability path is also uniquely determined. Thus, the core idea of FM is not to directly learn the change trajectory of data points but to learn the velocity field $v(x, t)$, allowing data points to move along the learned velocity field, transforming from $p_0(x)$ to $p_T(x)$. The sampling process can be considered as a transformation in the opposite direction of the velocity field, i.e., using the velocity field $-v(x, t)$ to transform from $p_T(x)$ to $p_0(x)$, completing the generation task.</p>
<p>The objective function of FM is very concise, minimizing the following loss:</p>
<p>$$
\mathcal{L}<em>{FM} = \mathbb E</em>{x_0, x_T, t} [||v_{\theta}(x_t, t) - v(x_t, t)||^2]
$$</p>
<p>where $x_t$ is an interpolated data point between $x_0$ and $x_T$, $v_{\theta}(x_t, t)$ is the learned velocity field, and $v(x_t, t)$ is the true interpolated velocity field, which can be derived from the interpolation path (details omitted here).</p>
<p><img src="images/7v2-f68b4326ce380d8eec5d2f1427baa757.jpg" alt=""></p>

</body>
</html>
